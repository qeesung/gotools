// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package sets

import (
	"encoding/json"
	"sort"
)

// StringSet adds set semantics to a map of string to bool values.
type StringSet map[string]bool

var _ json.Marshaler = StringSet{}
var _ json.Unmarshaler = &StringSet{}

// NewStringSet creates a new set of string values.
func NewStringSet(values ...string) StringSet {
	s := StringSet{}
	s.AddAll(values)
	return s
}

// Contains returns true if this set contains the given value.
func (s StringSet) Contains(value string) bool {
	return s[value]
}

// ContainsAny returns true if this set contains any value in the slice.
func (s StringSet) ContainsAny(values []string) bool {
	for _, value := range values {
		if s.Contains(value) {
			return true
		}
	}
	return false
}

// ContainsAll returns true if this set contains every value in the slice.
func (s StringSet) ContainsAll(values []string) bool {
	for _, value := range values {
		if !s.Contains(value) {
			return false
		}
	}
	return true
}

// SubsetOf returns true if every element in this set is in the other set.
func (s StringSet) SubsetOf(o StringSet) bool {
	for value := range s {
		if !o.Contains(value) {
			return false
		}
	}
	return true
}

// Add adds a single value to this set.
func (s StringSet) Add(value string) {
	s[value] = true
}

// AddAll adds multiple values to this set.
func (s StringSet) AddAll(values []string) {
	for _, value := range values {
		s.Add(value)
	}
}

// Update adds every value from the other set to this set.
func (s StringSet) Update(o StringSet) {
	for value := range o {
		s.Add(value)
	}
}

// Remove removes a single value from this set.
// If the value is not present this function is a no-op.
func (s StringSet) Remove(value string) {
	delete(s, value)
}

// RemoveAll removes multiple values from this set.
func (s StringSet) RemoveAll(values []string) {
	for _, value := range values {
		s.Remove(value)
	}
}

// Discard removes all values in this set that exist in the other set.
func (s StringSet) Discard(o StringSet) {
	for value := range o {
		s.Remove(value)
	}
}

// Union returns a new set containing all values from this and the other set.
func (s StringSet) Union(o StringSet) StringSet {
	ret := StringSet{}
	ret.Update(s)
	ret.Update(o)
	return ret
}

// Intersection returns a new set containing only values that exist in both sets.
func (s StringSet) Intersection(o StringSet) StringSet {
	ret := StringSet{}
	for value := range o {
		if s.Contains(value) {
			ret.Add(value)
		}
	}
	return ret
}

// Difference returns a new set containing all values in this set that don't exist in the other set.
func (s StringSet) Difference(o StringSet) StringSet {
	ret := StringSet{}
	ret.Update(s)
	ret.Discard(o)
	return ret
}

// Ordered returns an ordered slice of values from this set.
func (s StringSet) Ordered() []string {
	ret := make([]string, 0, len(s))
	for value := range s {
		ret = append(ret, value)
	}
	sort.Slice(ret, func(i, j int) bool {
		return ret[i] < ret[j]
	})
	return ret
}

// MarshalJSON implements json.Marshaler.
func (s StringSet) MarshalJSON() ([]byte, error) {
	var values []string
	if s != nil {
		values = s.Ordered()
	}
	return json.Marshal(values)
}

// UnmarshalJSON implements json.Unmarshaler.
func (s *StringSet) UnmarshalJSON(in []byte) error {
	var values []string
	if err := json.Unmarshal(in, &values); err != nil {
		return err
	}
	*s = StringSet{}
	s.AddAll(values)
	return nil
}
