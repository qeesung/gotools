// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package sets

import (
	"encoding/json"
	"sort"
)

// Int64Set represents a unique collection of int64 values.
type Int64Set map[int64]struct{}

var _ json.Marshaler = Int64Set{}
var _ json.Unmarshaler = &Int64Set{}

// NewInt64Set creates a new set of int64 values.
func NewInt64Set(values ...int64) Int64Set {
	s := Int64Set{}
	s.AddAll(values)
	return s
}

// Contains returns true if this set contains the given value.
func (s Int64Set) Contains(value int64) bool {
	_, found := s[value]
	return found
}

// ContainsAny returns true if this set contains any value in the slice.
func (s Int64Set) ContainsAny(values []int64) bool {
	for _, value := range values {
		if s.Contains(value) {
			return true
		}
	}
	return false
}

// ContainsAll returns true if this set contains every value in the slice.
func (s Int64Set) ContainsAll(values []int64) bool {
	for _, value := range values {
		if !s.Contains(value) {
			return false
		}
	}
	return true
}

// SubsetOf returns true if every element in this set is in the other set.
func (s Int64Set) SubsetOf(o Int64Set) bool {
	for value := range s {
		if !o.Contains(value) {
			return false
		}
	}
	return true
}

// Add adds a single value to this set.
func (s Int64Set) Add(value int64) {
	s[value] = struct{}{}
}

// AddAll adds multiple values to this set.
func (s Int64Set) AddAll(values []int64) {
	for _, value := range values {
		s.Add(value)
	}
}

// Update adds every value from the other set to this set.
func (s Int64Set) Update(o Int64Set) {
	for value := range o {
		s.Add(value)
	}
}

// Remove removes a single value from this set.
// If the value is not present this function is a no-op.
func (s Int64Set) Remove(value int64) {
	delete(s, value)
}

// RemoveAll removes multiple values from this set.
func (s Int64Set) RemoveAll(values []int64) {
	for _, value := range values {
		s.Remove(value)
	}
}

// Discard removes all values in this set that exist in the other set.
func (s Int64Set) Discard(o Int64Set) {
	for value := range o {
		s.Remove(value)
	}
}

// Union returns a new set containing all values from this and the other set.
func (s Int64Set) Union(o Int64Set) Int64Set {
	ret := Int64Set{}
	ret.Update(s)
	ret.Update(o)
	return ret
}

// Intersection returns a new set containing only values that exist in both sets.
func (s Int64Set) Intersection(o Int64Set) Int64Set {
	ret := Int64Set{}
	for value := range o {
		if s.Contains(value) {
			ret.Add(value)
		}
	}
	return ret
}

// Difference returns a new set containing all values in this set that don't exist in the other set.
func (s Int64Set) Difference(o Int64Set) Int64Set {
	ret := Int64Set{}
	ret.Update(s)
	ret.Discard(o)
	return ret
}

// Ordered returns an ordered slice of values from this set.
func (s Int64Set) Ordered() []int64 {
	ret := make([]int64, 0, len(s))
	for value := range s {
		ret = append(ret, value)
	}
	sort.Slice(ret, func(i, j int) bool {
		return ret[i] < ret[j]
	})
	return ret
}

// MarshalJSON implements json.Marshaler.
func (s Int64Set) MarshalJSON() ([]byte, error) {
	var values []int64
	if s != nil {
		values = s.Ordered()
	}
	return json.Marshal(values)
}

// UnmarshalJSON implements json.Unmarshaler.
func (s *Int64Set) UnmarshalJSON(in []byte) error {
	var values []int64
	if err := json.Unmarshal(in, &values); err != nil {
		return err
	}
	*s = Int64Set{}
	s.AddAll(values)
	return nil
}
