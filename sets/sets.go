// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package sets

import (
	"encoding/json"
	"sort"
)

// StringSet adds set semantics to a map of values.
type StringSet map[string]bool

var _ json.Marshaler = StringSet{}
var _ json.Unmarshaler = &StringSet{}

// NewStringSet creates a new set of String.
func NewStringSet(values ...string) StringSet {
	s := StringSet{}
	s.AddAll(values)
	return s
}

// Contains returns true if this set contains the given value.
func (s StringSet) Contains(value string) bool {
	return s[value]
}

// ContainsAny returns true if this set contains any value in the slice.
func (s StringSet) ContainsAny(values []string) bool {
	for _, value := range values {
		if s.Contains(value) {
			return true
		}
	}
	return false
}

// ContainsAll returns true if this set contains every value in the slice.
func (s StringSet) ContainsAll(values []string) bool {
	for _, value := range values {
		if !s.Contains(value) {
			return false
		}
	}
	return true
}

// SubsetOf returns true if every element in this set is in the other set.
func (s StringSet) SubsetOf(o StringSet) bool {
	for value := range s {
		if !o.Contains(value) {
			return false
		}
	}
	return true
}

// Add adds a single value to this set.
func (s StringSet) Add(value string) {
	s[value] = true
}

// AddAll adds multiple values to this set.
func (s StringSet) AddAll(values []string) {
	for _, value := range values {
		s.Add(value)
	}
}

// Update adds every value from the other set to this set.
func (s StringSet) Update(o StringSet) {
	for value := range o {
		s.Add(value)
	}
}

// Remove removes a single value from this set.
// If the value is not present this function is a no-op.
func (s StringSet) Remove(value string) {
	delete(s, value)
}

// RemoveAll removes multiple values from this set.
func (s StringSet) RemoveAll(values []string) {
	for _, value := range values {
		s.Remove(value)
	}
}

// Discard removes all values in this set that exist in the other set.
func (s StringSet) Discard(o StringSet) {
	for value := range o {
		s.Remove(value)
	}
}

// Union returns a new set containing all values from this and the other set.
func (s StringSet) Union(o StringSet) StringSet {
	ret := StringSet{}
	ret.Update(s)
	ret.Update(o)
	return ret
}

// Intersection returns a new set containing only values that exist in both sets.
func (s StringSet) Intersection(o StringSet) StringSet {
	ret := StringSet{}
	for value := range o {
		if s.Contains(value) {
			ret.Add(value)
		}
	}
	return ret
}

// Difference returns a new set containing all values in this set that don't exist in the other set.
func (s StringSet) Difference(o StringSet) StringSet {
	ret := StringSet{}
	ret.Update(s)
	ret.Discard(o)
	return ret
}

// Ordered returns an ordered slice of values from this set.
func (s StringSet) Ordered() []string {
	ret := make([]string, 0, len(s))
	for value := range s {
		ret = append(ret, value)
	}
	sort.Slice(ret, func(i, j int) bool {
		return ret[i] < ret[j]
	})
	return ret
}

func (s StringSet) MarshalJSON() ([]byte, error) {
	var values []string
	if s != nil {
		values = s.Ordered()
	}
	return json.Marshal(values)
}

func (s *StringSet) UnmarshalJSON(in []byte) error {
	var values []string
	if err := json.Unmarshal(in, &values); err != nil {
		return err
	}
	*s = StringSet{}
	s.AddAll(values)
	return nil
}

// IntSet adds set semantics to a map of values.
type IntSet map[int]bool

var _ json.Marshaler = IntSet{}
var _ json.Unmarshaler = &IntSet{}

// NewIntSet creates a new set of Int.
func NewIntSet(values ...int) IntSet {
	s := IntSet{}
	s.AddAll(values)
	return s
}

// Contains returns true if this set contains the given value.
func (s IntSet) Contains(value int) bool {
	return s[value]
}

// ContainsAny returns true if this set contains any value in the slice.
func (s IntSet) ContainsAny(values []int) bool {
	for _, value := range values {
		if s.Contains(value) {
			return true
		}
	}
	return false
}

// ContainsAll returns true if this set contains every value in the slice.
func (s IntSet) ContainsAll(values []int) bool {
	for _, value := range values {
		if !s.Contains(value) {
			return false
		}
	}
	return true
}

// SubsetOf returns true if every element in this set is in the other set.
func (s IntSet) SubsetOf(o IntSet) bool {
	for value := range s {
		if !o.Contains(value) {
			return false
		}
	}
	return true
}

// Add adds a single value to this set.
func (s IntSet) Add(value int) {
	s[value] = true
}

// AddAll adds multiple values to this set.
func (s IntSet) AddAll(values []int) {
	for _, value := range values {
		s.Add(value)
	}
}

// Update adds every value from the other set to this set.
func (s IntSet) Update(o IntSet) {
	for value := range o {
		s.Add(value)
	}
}

// Remove removes a single value from this set.
// If the value is not present this function is a no-op.
func (s IntSet) Remove(value int) {
	delete(s, value)
}

// RemoveAll removes multiple values from this set.
func (s IntSet) RemoveAll(values []int) {
	for _, value := range values {
		s.Remove(value)
	}
}

// Discard removes all values in this set that exist in the other set.
func (s IntSet) Discard(o IntSet) {
	for value := range o {
		s.Remove(value)
	}
}

// Union returns a new set containing all values from this and the other set.
func (s IntSet) Union(o IntSet) IntSet {
	ret := IntSet{}
	ret.Update(s)
	ret.Update(o)
	return ret
}

// Intersection returns a new set containing only values that exist in both sets.
func (s IntSet) Intersection(o IntSet) IntSet {
	ret := IntSet{}
	for value := range o {
		if s.Contains(value) {
			ret.Add(value)
		}
	}
	return ret
}

// Difference returns a new set containing all values in this set that don't exist in the other set.
func (s IntSet) Difference(o IntSet) IntSet {
	ret := IntSet{}
	ret.Update(s)
	ret.Discard(o)
	return ret
}

// Ordered returns an ordered slice of values from this set.
func (s IntSet) Ordered() []int {
	ret := make([]int, 0, len(s))
	for value := range s {
		ret = append(ret, value)
	}
	sort.Slice(ret, func(i, j int) bool {
		return ret[i] < ret[j]
	})
	return ret
}

func (s IntSet) MarshalJSON() ([]byte, error) {
	var values []int
	if s != nil {
		values = s.Ordered()
	}
	return json.Marshal(values)
}

func (s *IntSet) UnmarshalJSON(in []byte) error {
	var values []int
	if err := json.Unmarshal(in, &values); err != nil {
		return err
	}
	*s = IntSet{}
	s.AddAll(values)
	return nil
}

// Int64Set adds set semantics to a map of values.
type Int64Set map[int64]bool

var _ json.Marshaler = Int64Set{}
var _ json.Unmarshaler = &Int64Set{}

// NewInt64Set creates a new set of Int64.
func NewInt64Set(values ...int64) Int64Set {
	s := Int64Set{}
	s.AddAll(values)
	return s
}

// Contains returns true if this set contains the given value.
func (s Int64Set) Contains(value int64) bool {
	return s[value]
}

// ContainsAny returns true if this set contains any value in the slice.
func (s Int64Set) ContainsAny(values []int64) bool {
	for _, value := range values {
		if s.Contains(value) {
			return true
		}
	}
	return false
}

// ContainsAll returns true if this set contains every value in the slice.
func (s Int64Set) ContainsAll(values []int64) bool {
	for _, value := range values {
		if !s.Contains(value) {
			return false
		}
	}
	return true
}

// SubsetOf returns true if every element in this set is in the other set.
func (s Int64Set) SubsetOf(o Int64Set) bool {
	for value := range s {
		if !o.Contains(value) {
			return false
		}
	}
	return true
}

// Add adds a single value to this set.
func (s Int64Set) Add(value int64) {
	s[value] = true
}

// AddAll adds multiple values to this set.
func (s Int64Set) AddAll(values []int64) {
	for _, value := range values {
		s.Add(value)
	}
}

// Update adds every value from the other set to this set.
func (s Int64Set) Update(o Int64Set) {
	for value := range o {
		s.Add(value)
	}
}

// Remove removes a single value from this set.
// If the value is not present this function is a no-op.
func (s Int64Set) Remove(value int64) {
	delete(s, value)
}

// RemoveAll removes multiple values from this set.
func (s Int64Set) RemoveAll(values []int64) {
	for _, value := range values {
		s.Remove(value)
	}
}

// Discard removes all values in this set that exist in the other set.
func (s Int64Set) Discard(o Int64Set) {
	for value := range o {
		s.Remove(value)
	}
}

// Union returns a new set containing all values from this and the other set.
func (s Int64Set) Union(o Int64Set) Int64Set {
	ret := Int64Set{}
	ret.Update(s)
	ret.Update(o)
	return ret
}

// Intersection returns a new set containing only values that exist in both sets.
func (s Int64Set) Intersection(o Int64Set) Int64Set {
	ret := Int64Set{}
	for value := range o {
		if s.Contains(value) {
			ret.Add(value)
		}
	}
	return ret
}

// Difference returns a new set containing all values in this set that don't exist in the other set.
func (s Int64Set) Difference(o Int64Set) Int64Set {
	ret := Int64Set{}
	ret.Update(s)
	ret.Discard(o)
	return ret
}

// Ordered returns an ordered slice of values from this set.
func (s Int64Set) Ordered() []int64 {
	ret := make([]int64, 0, len(s))
	for value := range s {
		ret = append(ret, value)
	}
	sort.Slice(ret, func(i, j int) bool {
		return ret[i] < ret[j]
	})
	return ret
}

func (s Int64Set) MarshalJSON() ([]byte, error) {
	var values []int64
	if s != nil {
		values = s.Ordered()
	}
	return json.Marshal(values)
}

func (s *Int64Set) UnmarshalJSON(in []byte) error {
	var values []int64
	if err := json.Unmarshal(in, &values); err != nil {
		return err
	}
	*s = Int64Set{}
	s.AddAll(values)
	return nil
}

// Uint64Set adds set semantics to a map of values.
type Uint64Set map[uint64]bool

var _ json.Marshaler = Uint64Set{}
var _ json.Unmarshaler = &Uint64Set{}

// NewUint64Set creates a new set of Uint64.
func NewUint64Set(values ...uint64) Uint64Set {
	s := Uint64Set{}
	s.AddAll(values)
	return s
}

// Contains returns true if this set contains the given value.
func (s Uint64Set) Contains(value uint64) bool {
	return s[value]
}

// ContainsAny returns true if this set contains any value in the slice.
func (s Uint64Set) ContainsAny(values []uint64) bool {
	for _, value := range values {
		if s.Contains(value) {
			return true
		}
	}
	return false
}

// ContainsAll returns true if this set contains every value in the slice.
func (s Uint64Set) ContainsAll(values []uint64) bool {
	for _, value := range values {
		if !s.Contains(value) {
			return false
		}
	}
	return true
}

// SubsetOf returns true if every element in this set is in the other set.
func (s Uint64Set) SubsetOf(o Uint64Set) bool {
	for value := range s {
		if !o.Contains(value) {
			return false
		}
	}
	return true
}

// Add adds a single value to this set.
func (s Uint64Set) Add(value uint64) {
	s[value] = true
}

// AddAll adds multiple values to this set.
func (s Uint64Set) AddAll(values []uint64) {
	for _, value := range values {
		s.Add(value)
	}
}

// Update adds every value from the other set to this set.
func (s Uint64Set) Update(o Uint64Set) {
	for value := range o {
		s.Add(value)
	}
}

// Remove removes a single value from this set.
// If the value is not present this function is a no-op.
func (s Uint64Set) Remove(value uint64) {
	delete(s, value)
}

// RemoveAll removes multiple values from this set.
func (s Uint64Set) RemoveAll(values []uint64) {
	for _, value := range values {
		s.Remove(value)
	}
}

// Discard removes all values in this set that exist in the other set.
func (s Uint64Set) Discard(o Uint64Set) {
	for value := range o {
		s.Remove(value)
	}
}

// Union returns a new set containing all values from this and the other set.
func (s Uint64Set) Union(o Uint64Set) Uint64Set {
	ret := Uint64Set{}
	ret.Update(s)
	ret.Update(o)
	return ret
}

// Intersection returns a new set containing only values that exist in both sets.
func (s Uint64Set) Intersection(o Uint64Set) Uint64Set {
	ret := Uint64Set{}
	for value := range o {
		if s.Contains(value) {
			ret.Add(value)
		}
	}
	return ret
}

// Difference returns a new set containing all values in this set that don't exist in the other set.
func (s Uint64Set) Difference(o Uint64Set) Uint64Set {
	ret := Uint64Set{}
	ret.Update(s)
	ret.Discard(o)
	return ret
}

// Ordered returns an ordered slice of values from this set.
func (s Uint64Set) Ordered() []uint64 {
	ret := make([]uint64, 0, len(s))
	for value := range s {
		ret = append(ret, value)
	}
	sort.Slice(ret, func(i, j int) bool {
		return ret[i] < ret[j]
	})
	return ret
}

func (s Uint64Set) MarshalJSON() ([]byte, error) {
	var values []uint64
	if s != nil {
		values = s.Ordered()
	}
	return json.Marshal(values)
}

func (s *Uint64Set) UnmarshalJSON(in []byte) error {
	var values []uint64
	if err := json.Unmarshal(in, &values); err != nil {
		return err
	}
	*s = Uint64Set{}
	s.AddAll(values)
	return nil
}
